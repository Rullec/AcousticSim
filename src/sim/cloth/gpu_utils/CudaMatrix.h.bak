// /**
//  * 公司：凌笛数码
//  * 版权信息：凌笛数码所有
//  * 描述：布料仿真
//  * 作者：王振东
//  * 日期：2018/11/27
//  *
//  */

// #ifndef SDSIMULATION_SimMatrix_H
// #define SDSIMULATION_SimMatrix_H

// #include "CudaVector.h"
// #include <iomanip>
// // #include "SDUtility.h"

// // SIM_NAMESPACE_BEGIN
// // SIM_SIMULATION_SPACE_BEGIN

// #define SIM_MAT2_ALIGN(Type)                                                   \
//     SIM_ALIGN(SIM_MAX(sizeof(Type) * 4, 16)) //!	Maximum align bits
//                                              //!-> 64.
// #define SIM_MAT4_ALIGN(Type)                                                   \
//     SIM_ALIGN(SIM_MAX(sizeof(Type) * 4, 16)) //!	Maximum align bits
//                                              //!-> 64.

// template <typename Type>
// SIM_CUDA_CALLABLE bool JacobiImplement(Type *A, int astep, Type *W, Type *V,
//                                        int vstep, int n, int *buf);

// /*!
//  * \class Template SimMatrix
//  *
//  * \brief Column Major Matrix
//  *
//  * \author zhendong_wang
//  * \date 十二月 2019
//  */

// template <class Type, int N, int M> class SimMatrix
// {

// public:
//     static constexpr int nElements = N * M;

// protected:
//     Type m_data[nElements];

// public:
//     SIM_CUDA_CALLABLE SimMatrix()
//     {
//         std::memset(m_data, 0, sizeof(Type) * nElements);
//     }
//     SIM_CUDA_CALLABLE explicit SimMatrix(const Type &rhs)
//     {
//         for (int i = 0; i < nElements; ++i)
//         {
//             m_data[i] = rhs;
//         }
//     }

//     // SIM_CUDA_CALLABLE Int2	Size()		const	{ return Int2(N, M); }
//     SIM_CUDA_CALLABLE int RowSize() const { return N; }
//     SIM_CUDA_CALLABLE int ColSize() const { return M; }

//     SIM_CUDA_CALLABLE const Type *ptr() const { return m_data; }
//     SIM_CUDA_CALLABLE Type *ptr() { return m_data; }

//     SIM_CUDA_CALLABLE const Type &operator()(int i, int j) const
//     {
//         return m_data[j * N + i];
//     }
//     SIM_CUDA_CALLABLE Type &operator()(int i, int j)
//     {
//         return m_data[j * N + i];
//     }
//     SIM_CUDA_CALLABLE const Type &operator[](int i) const { return m_data[i]; }
//     SIM_CUDA_CALLABLE Type &operator[](int i) { return m_data[i]; }

// // Operators: +, - with mat
// #define SimMatrix_ARITHMATIC1(OP)                                              \
//     SIM_CUDA_CALLABLE SimMatrix operator OP(const SimMatrix &rhs) const        \
//     {                                                                          \
//         SimMatrix out;                                                         \
//         for (int i = 0; i < nElements; ++i)                                    \
//             out[i] = m_data[i] OP rhs[i];                                      \
//         return out;                                                            \
//     }
// // Operators: +=, -=, = with mat
// #define SimMatrix_ARITHMATIC2(OP)                                              \
//     SIM_CUDA_CALLABLE SimMatrix &operator OP(const SimMatrix &rhs)             \
//     {                                                                          \
//         for (int i = 0; i < nElements; ++i)                                    \
//             m_data[i] OP rhs[i];                                               \
//         return *this;                                                          \
//     }
// // Arithmatic Operators: +, -, ! (sign operatior)
// #define SimMatrix_ARITHMATIC3(OP)                                              \
//     SIM_CUDA_CALLABLE SimMatrix operator OP() const                            \
//     {                                                                          \
//         SimMatrix rhs;                                                         \
//         for (int i = 0; i < nElements; ++i)                                    \
//             rhs[i] = OP m_data[i];                                             \
//         return rhs;                                                            \
//     }
//     // Operators: +, -, *, /, &, |, ^ with scalar
// #define SimMatrix_ARITHMATIC1_SCALAR(OP)                                       \
//     SIM_CUDA_CALLABLE SimMatrix operator OP(const Type &rhs) const             \
//     {                                                                          \
//         SimMatrix<Type, N, M> out;                                             \
//         for (int i = 0; i < nElements; ++i)                                    \
//             out[i] = m_data[i] OP rhs;                                         \
//         return out;                                                            \
//     }
//     // Operators: +=, -=, *=, /=, &=, |=, ^= with scalar
// #define SimMatrix_ARITHMATIC2_SCALAR(OP)                                       \
//     SIM_CUDA_CALLABLE SimMatrix &operator OP(const Type &rhs)                  \
//     {                                                                          \
//         for (int i = 0; i < nElements; ++i)                                    \
//             m_data[i] OP rhs;                                                  \
//         return *this;                                                          \
//     }

//     SimMatrix_ARITHMATIC1(+) SimMatrix_ARITHMATIC1(-)

//         SimMatrix_ARITHMATIC2(+=) SimMatrix_ARITHMATIC2(-=)

//             SimMatrix_ARITHMATIC3(!) SimMatrix_ARITHMATIC3(
//                 -) SimMatrix_ARITHMATIC3(+)

//                 SimMatrix_ARITHMATIC1_SCALAR(+) SimMatrix_ARITHMATIC1_SCALAR(
//                     -) SimMatrix_ARITHMATIC1_SCALAR(*)
//                     SimMatrix_ARITHMATIC1_SCALAR(
//                         /) SimMatrix_ARITHMATIC1_SCALAR(&)
//                         SimMatrix_ARITHMATIC1_SCALAR(
//                             |) SimMatrix_ARITHMATIC1_SCALAR(^)

//                             SimMatrix_ARITHMATIC2_SCALAR(
//                                 +=) SimMatrix_ARITHMATIC2_SCALAR(-=)
//                                 SimMatrix_ARITHMATIC2_SCALAR(*=)
//                                     SimMatrix_ARITHMATIC2_SCALAR(/=)
//                                         SimMatrix_ARITHMATIC2_SCALAR(&=)
//                                             SimMatrix_ARITHMATIC2_SCALAR(|=)
//                                                 SimMatrix_ARITHMATIC2_SCALAR(^=)

// #undef SimMatrix_ARITHMATIC1
// #undef SimMatrix_ARITHMATIC2
// #undef SimMatrix_ARITHMATIC3
// #undef SimMatrix_ARITHMATIC1_SCALAR
// #undef SimMatrix_ARITHMATIC2_SCALAR

//         // Matrix Product Operators
//         template <int K>
//         SIM_CUDA_CALLABLE SimMatrix<Type, N, K>
//         operator*(const SimMatrix<Type, M, K> &rhs) const
//     {
//         SimMatrix<Type, N, K> ans;
//         for (int i = 0; i < N; ++i)
//         {
//             for (int k = 0; k < K; ++k)
//             {
//                 Type s(0);
//                 for (int j = 0; j < M; ++j)
//                 {
//                     s += (*this)(i, j) * rhs(j, k);
//                 }
//                 ans(i, k) = s;
//             }
//         }
//         return ans;
//     }
//     SIM_CUDA_CALLABLE tSimVector<Type, N>
//     operator*(const tSimVector<Type, M> &rhs) const
//     {
//         tSimVector<Type, N> ans;
//         for (size_t i = 0; i < N; ++i)
//         {
//             Type s(0);
//             for (size_t j = 0; j < M; ++j)
//             {
//                 s += (*this)(i, j) * rhs[j];
//             }
//             ans[i] = s;
//         }
//         return ans;
//     }
//     SIM_CUDA_CALLABLE SimMatrix P2PProduct(const SimMatrix &rhs) const
//     {
//         SimMatrix ans;
//         for (size_t i = 0; i < nElements; ++i)
//         {
//             ans[i] = m_data[i] * rhs[i];
//         }
//         return ans;
//     }
//     SIM_CUDA_CALLABLE SimMatrix P2PDivide(const SimMatrix &rhs) const
//     {
//         SimMatrix<Type, N, M> out;
//         for (int i = 0; i < nElements; ++i)
//         {
//             out[i] = m_data[i] / rhs[i];
//         }
//         return out;
//     }
//     template <int K, int L>
//     SIM_CUDA_CALLABLE SimMatrix<Type, N * K, M * L>
//     KroneckerProduct(const SimMatrix<Type, K, L> &rhs) const
//     {
//         SimMatrix<Type, N * K, M * L> ans;
//         for (int i = 0; i < N; i++)
//         {
//             for (int j = 0; j < M; j++)
//             {
//                 Type ij = (*this)(i, j);
//                 for (int p = 0; p < K; ++p)
//                 {
//                     for (int q = 0; q < K; ++q)
//                     {
//                         ans(i * K + p, j * L + q) = ij * rhs(p, q);
//                     }
//                 }
//             }
//         }
//     }
//     SIM_CUDA_CALLABLE SimMatrix<Type, M, N> Transpose() const
//     {
//         SimMatrix<Type, M, N> trans;
//         for (int i = 0; i < N; ++i)
//             for (int j = 0; j < M; ++j)
//                 trans(j, i) = m_data[j * N + i];

//         return trans;
//     }
//     SIM_CUDA_CALLABLE Type FrobeniusNorm() const
//     {
//         Type sum(0);
//         for (int i = 0; i < N; ++i)
//             for (int j = 0; j < M; ++j)
//                 sum += sqr(m_data[j * N + i]);
//         return std::sqrt(sum);
//     }
//     SIM_CUDA_CALLABLE tSimVector<Type, M> Row(int row)
//     {
//         const SimMatrix<Type, N, M> &self = *this;

//         tSimVector<Type, M> x;
//         for (int k = 0; k < M; ++k)
//             x[k] = self(row, k);
//         return x;
//     }
//     SIM_CUDA_CALLABLE tSimVector<Type, N> Column(int col)
//     {
//         const SimMatrix<Type, N, M> &self = *this;

//         tSimVector<Type, N> x;
//         for (int k = 0; k < N; ++k)
//             x[k] = self(k, col);
//         return x;
//     }
//     SIM_CUDA_CALLABLE void SetRow(int row, const tSimVector<Type, M>  & vec)
//     {
//         SimMatrix<Type, N, M> &self = *this;

//         tSimVector<Type, M> x;
//         for (int k = 0; k < M; ++k)
//             self(row, k) = vec[k];
//     }
//     SIM_CUDA_CALLABLE void SetColumn(int col, const tSimVector<Type, N> & vec)
//     {
//         SimMatrix<Type, N, M> &self = *this;

//         tSimVector<Type, N> x;
//         for (int k = 0; k < N; ++k)
//             self(k, col) = vec[k];
//     }
//     template <int K, int L>
//     SIM_CUDA_CALLABLE SimMatrix<Type, K, L> Block(int row, int col)
//     {
//         SimMatrix<Type, K, L> ans;
//         for (int i = 0; i < K; ++i)
//         {
//             for (int j = 0; j < L; ++j)
//             {
//                 ans(i, j) = (*this)(i + row, j + col);
//             }
//         }
//         return ans;
//     }
//     template <int K, int L>
//     SIM_CUDA_CALLABLE void SetBlock(const SimMatrix<Type, K, L> &block, int row,
//                                     int col)
//     {
//         SimMatrix &self = *this;
//         for (int i = 0; i < K; ++i)
//         {
//             for (int j = 0; j < L; ++j)
//             {
//                 self(i + row, j + col) = block(i, j);
//             }
//         }
//     }
//     static SIM_CUDA_CALLABLE SimMatrix Zeros()
//     {
//         SimMatrix zero;
//         for (int i = 0; i < zero.nElements; ++i)
//             zero.m_data[i] = Type(0);

//         return zero;
//     }
//     static SIM_CUDA_CALLABLE SimMatrix Ones()
//     {
//         SimMatrix one;
//         for (int i = 0; i < one.nElements; ++i)
//             one.m_data[i] = Type(1);

//         return one;
//     }
// };

// // friend SimMatrix<Type, N, M> operator OP (const Type& lhs, const
// // SimMatrix<Type, N, M>& rhs); Arithmatic Operators: +, -, *, / scale with mat
// #define SimMatrix_ARITHMATIC_FRIEND(OP)                                        \
//     template <typename Type, int N, int M>                                     \
//     SIM_CUDA_CALLABLE_INLINE SimMatrix<Type, N, M> operator OP(                \
//         const Type &lhs, const SimMatrix<Type, N, M> &rhs)                     \
//     {                                                                          \
//         SimMatrix<Type, N, M> ans;                                             \
//         for (int i = 0; i < rhs.nElements; ++i)                                \
//             ans[i] = lhs OP rhs[i];                                            \
//         return ans;                                                            \
//     }

// SimMatrix_ARITHMATIC_FRIEND(+) SimMatrix_ARITHMATIC_FRIEND(-)
//     SimMatrix_ARITHMATIC_FRIEND(*) SimMatrix_ARITHMATIC_FRIEND(/)

// #undef SimMatrix_ARITHMATIC_FRIEND

//     /*!
//      * \class SimMatrixSqr
//      *
//      * \brief
//      *
//      * \author zhendong_wang
//      * \date 十二月 2019
//      */

// //     template <class Type, int N>
// //     class SimMatrixSqr : public SimMatrix<Type, N, N>
// // {

// // public:
// //     SIM_CUDA_CALLABLE Type Trace() const
// //     {
// //         const SimMatrixSqr &self = *this;
// //         Type tr(0);
// //         for (int i = 0; i < N; ++i)
// //         {
// //             tr += self(i, i);
// //         }
// //         return tr;
// //     }

// //     template <int K>
// //     SIM_CUDA_CALLABLE SimMatrix<Type, N, K>
// //     operator*(const SimMatrix<Type, N, K> &rhs) const
// //     {
// //         SimMatrix<Type, N, K> ans;
// //         for (int i = 0; i < N; ++i)
// //         {
// //             for (int k = 0; k < K; ++k)
// //             {
// //                 Type s(0);
// //                 for (int j = 0; j < N; ++j)
// //                 {
// //                     s += (*this)(i, j) * rhs(j, k);
// //                 }
// //                 ans(i, k) = s;
// //             }
// //         }
// //         return ans;
// //     }

// //     SIM_CUDA_CALLABLE tSimVector<Type, N> Diagonal() const
// //     {
// //         const SimMatrixSqr<Type, N> &self = *this;
// //         tSimVector<Type, N> x;
// //         for (int i = 0; i < N; ++i)
// //         {
// //             x[i] = self(i, i);
// //         }
// //         return x;
// //     }

// //     SIM_CUDA_CALLABLE SimMatrixSqr<Type, N> &
// //     FromDiagonal(const tSimVector<Type, N> &x)
// //     {
// //         SimMatrixSqr<Type, N> &self = *this;

// //         for (int i = 0; i < N; ++i)
// //             self[i] = 0;
// //         for (int i = 0; i < N; ++i)
// //             self(i, i) = x[i];

// //         return self;
// //     }

// //     /**
// //      * LU Decomposition for small matrices with Row permutation
// //      * A may be (*this)
// //      * Return:	0 if pivot detected
// //      *			1 if matrix is positive definite
// //      *			-1 if matrix is negative definite
// //      * */
// //     SIM_CUDA_CALLABLE int LU(SimMatrix<Type, N, N> &A,
// //                              tSimVector<int, N> &permute) const
// //     {
// //         int i, j, k, p = 1;
// //         A = (*this);
// //         for (i = 0; i < N; ++i)
// //             permute[i] = i;
// //         for (i = 0; i < N; ++i)
// //         {
// //             k = i;
// //             for (j = i + 1; j < N; ++j)
// //                 if (std::abs(A(j, i)) > std::abs(A(k, i)))
// //                     k = j;
// //             std::swap(permute[i], permute[k]);
// //             if (std::abs(A(k, i)) < std::numeric_limits<Type>::epsilon())
// //                 return 0;
// //             if (k != i)
// //             {
// //                 for (j = 0; j < N; ++j)
// //                     std::swap(A(i, j), A(k, j));
// //                 p = -p;
// //             }

// //             Type d = -1 / A(i, i);

// //             for (j = i + 1; j < N; ++j)
// //             {
// //                 Type alpha = A(j, i) * d;
// //                 for (k = i + 1; k < N; ++k)
// //                     A(j, k) += alpha * A(i, k);
// //                 A(j, i) = -alpha;
// //             }
// //         }
// //         return p;
// //     }
// //     /**
// //      * LU Decomposition for small matrices with Row permutation
// //      * L * U = (*this) and L & U must not be (*this)
// //      * Return:	0 if pivot detected
// //      *			1 if matrix is positive definite
// //      *			-1 if matrix is negative definite
// //      * */
// //     SIM_CUDA_CALLABLE int LU(SimMatrix<Type, N, N> &L,
// //                              SimMatrix<Type, N, N> &U) const
// //     {
// //         SimMatrixSqr<Type, N> A;
// //         tSimVector<int, N> p;
// //         int r = LU(A, p);
// //         L = Type(0);
// //         U = Type(0);
// //         for (int x = 0; x < N; ++x)
// //         {
// //             for (int y = 0; y < N; ++y)
// //             {
// //                 if (y == x)
// //                     L(p[y], x) = 1, U(y, x) = A(y, x);
// //                 else if (y > x)
// //                     L(p[y], x) = A(y, x);
// //                 else
// //                     U(y, x) = A(y, x);
// //             }
// //         }
// //         return r;
// //     }
// //     SIM_CUDA_CALLABLE int LU(SimMatrix<Type, N, N> &L, SimMatrix<Type, N, N> &U,
// //                              tSimVector<int, N> &permute) const
// //     {
// //         SimMatrixSqr<Type, N> A;
// //         int r = LU(A, permute);
// //         L = Type(0);
// //         U = Type(0);
// //         for (int x = 0; x < N; ++x)
// //         {
// //             for (int y = 0; y < N; ++y)
// //             {
// //                 if (y == x)
// //                     L(y, x) = 1, U(y, x) = A(y, x);
// //                 else if (y > x)
// //                     L(y, x) = A(y, x);
// //                 else
// //                     U(y, x) = A(y, x);
// //             }
// //         }
// //         return r;
// //     }
// //     /**
// //      * back substitution given lu factorized matrix
// //      * (*this) = p[L U], L*U*x = p(b)
// //      * */
// //     SIM_CUDA_CALLABLE void LUBackSubstitute(const tSimVector<int, N> &p,
// //                                             tSimVector<Type, N> b,
// //                                             tSimVector<Type, N> &x) const
// //     {
// //         tSimVector<Type, N> ux;
// //         // backup substitution for L: L*ux = P(b)
// //         for (size_t i = 0; i < N; ++i)
// //         {
// //             ux[i] = b[p[i]];
// //             for (size_t j = i + 1; j < N; ++j)
// //             {
// //                 b[p[j]] -= b[p[i]] * (*this)(j, i);
// //             }
// //         }

// //         // backup subsitution for U: U*x = ux
// //         for (int i = int(N - 1); i >= 0; --i)
// //         {
// //             const Type invd = 1 / (*this)(i, i);

// //             x[i] = ux[i] * invd;

// //             if (i == 0)
// //                 break;

// //             for (int j = i - 1; j >= 0; --j)
// //             {
// //                 ux[j] -= ux[i] * (*this)(j, i) * invd;
// //             }
// //         }
// //     }

// //     SIM_CUDA_CALLABLE tSimVector<Type, N>
// //     Solve(const tSimVector<Type, N> &b) const
// //     {
// //         SimMatrixSqr<Type, N> A = (*this);
// //         tSimVector<Type, N> x;
// //         tSimVector<int, N> p;
// //         int r = LU(A, p);

// //         if (r == 0)
// //         {
// //             x = std::numeric_limits<Type>::infinity();
// //             return x;
// //         }

// //         A.LUBackSubstitute(p, b, x);

// //         return x;
// //     }

// //     SIM_CUDA_CALLABLE void Inverse(SimMatrix<Type, N, N> &result) const
// //     {
// //         tSimVector<Type, N> x, b;
// //         tSimVector<int, N> p;
// //         SimMatrixSqr<Type, N> A;
// //         int r = LU(A, p);
// //         if (r == 0)
// //         {
// //             result = std::numeric_limits<Type>::infinity();
// //             return;
// //         }
// //         for (size_t i = 0; i < N; ++i)
// //         {
// //             b = 0;
// //             b[i] = 1;
// //             A.LUBackSubstitute(p, b, x);
// //             for (size_t j = 0; j < N; ++j)
// //                 result(j, i) = x[j];
// //         }
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr Inverse() const
// //     {
// //         SimMatrixSqr r(*this);
// //         Inverse(r);
// //         return r;
// //     }

// //     SIM_CUDA_CALLABLE Type Det() const
// //     {
// //         SimMatrixSqr A = (*this);
// //         tSimVector<int, N> p;
// //         int r = A.LU(A, p);
// //         if (r == 0)
// //             return 0;
// //         Type s = 1;
// //         for (size_t i = 0; i < N; ++i)
// //             s *= A(i, i);
// //         return r * s;
// //     }

// //     SIM_CUDA_CALLABLE void Eigen(tSimVector<Type, N> &eigenValues,
// //                                  SimMatrix<Type, N, N> &eigenVectors) const
// //     {
// //         int buf[N * N + N * 5 + 32];

// //         SimMatrixSqr A = *this;

// //         JacobiImplement(A.ptr(), N, eigenValues.ptr(), eigenVectors.ptr(), N, N,
// //                         buf);
// //     }
// //     SIM_CUDA_CALLABLE void Eigen(tSimVector<Type, N> &eigenValues) const
// //     {
// //         int buf[N * N + N * 5 + 32];

// //         SimMatrixSqr self = *this;

// //         JacobiImplement(self.ptr(), N, eigenValues.ptr(), (Type *)0, N, N, buf);
// //     }
// //     SIM_CUDA_CALLABLE tSimVector<Type, N> Eigen() const
// //     {
// //         tSimVector<Type, N> x;
// //         Eigen(x);
// //         return x;
// //     }

// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator*=(const SimMatrixSqr &rhs)
// //     {
// //         SimMatrixSqr &self = *this;
// //         self = self * rhs;
// //         return self;
// //     }

// //     // Newton iteration method for polor decomposition: argmin{||self-R'*R||}
// //     // subject to R'*R=I. and self = R*S.
// //     SIM_CUDA_CALLABLE inline void
// //     PolorDecomposition(SimMatrixSqr<Type, N> &R, SimMatrixSqr<Type, N> &S,
// //                        const Type &tol = Type(1e-5))
// //     {
// //         R = *this;
// //         SimMatrixSqr R1, Y;
// //         while ((R1 - R).FNorm() > tol)
// //         {
// //             // R1 = R;
// //             // Y = R.inverse();
// //             // double a = sqrt(R.norm(1) * R.norm(-1));
// //             // double b = sqrt(Y.norm(1) * Y.norm(-1));
// //             // double gama = sqrt(b/a);
// //             // R = (gama*R + 1.0/gama * Y.transpose())*0.5;
// //             R1 = R;
// //             R = 0.5 * (R + R.inv().trans());
// //         }
// //         S = R.inv() * (*this);
// //     }

// //     //////////////////////////////////////////////////////////////////////////

// //     static SIM_CUDA_CALLABLE SimMatrixSqr Identity()
// //     {
// //         SimMatrixSqr I = SimMatrixSqr::Zeros();
// //         for (int i = 0; i < N; ++i)
// //         {
// //             I(i, i) = 1;
// //         }
// //         return I;
// //     }
// // };

// // /*!
// //  * \class SimMatrix2
// //  *
// //  * \brief
// //  *
// //  * \author zhendong_wang
// //  * \date 十二月 2019
// //  */

// // template <class Type> class SIM_MAT2_ALIGN(Type) SimMatrixSqr<Type, 2>
// // {
// // public:
// //     static constexpr int DIM = 2;
// //     static constexpr int nElements = DIM * DIM;
// //     Type m_data[4];

// // public:
// //     SIM_CUDA_CALLABLE SimMatrixSqr()
// //     {
// //         Type zero(0);
// //         m_data[0] = zero;
// //         m_data[1] = zero;
// //         m_data[2] = zero;
// //         m_data[3] = zero;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr(const Type &v)
// //     {
// //         m_data[0] = v;
// //         m_data[1] = v;
// //         m_data[2] = v;
// //         m_data[3] = v;
// //     }

// //     SIM_CUDA_CALLABLE const Type &operator()(int i, int j) const
// //     {
// //         return m_data[j * N + i];
// //     }
// //     SIM_CUDA_CALLABLE Type &operator()(int i, int j)
// //     {
// //         return m_data[j * N + i];
// //     }
// //     SIM_CUDA_CALLABLE const Type &operator[](int i) const { return m_data[i]; }
// //     SIM_CUDA_CALLABLE Type &operator[](int i) { return m_data[i]; }
// //     SIM_CUDA_CALLABLE SimMatrixSqr operator*(const Type &rhs) const
// //     {
// //         return SimMatrix<Type, 2, 2>::operator*(rhs);
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator*=(const Type &rhs)
// //     {
// //         for (size_t i = 0; i < nElements; ++i)
// //             (*this)[i] *= rhs;
// //         return *this;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator=(const SimMatrix<Type, 2, 2> &rhs)
// //     {
// //         m_data[0] = rhs(0);
// //         m_data[1] = rhs[1];
// //         m_data[2] = rhs[2];
// //         m_data[3] = rhs[3];
// //     }

// // // Operators: +=, -=, = with mat
// // #define SimMatrix_ARITHMATIC2(OP)                                              \
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator OP(const SimMatrixSqr &rhs)       \
// //     {                                                                          \
// //         for (int i = 0; i < nElements; ++i)                                    \
// //             m_data[i] OP rhs[i];                                               \
// //         return *this;                                                          \
// //     }

// //     SimMatrix_ARITHMATIC2(+=) SimMatrix_ARITHMATIC2(-=)
// // #undef SimMatrix_ARITHMATIC2

// //         SIM_CUDA_CALLABLE Type Det() const
// //     {
// //         return m_data[0] * m_data[3] - m_data[1] * m_data[2];
// //     }
// //     SIM_CUDA_CALLABLE void Inverse(SimMatrixSqr &result) const
// //     {
// //         Type dt = 1 / Det();
// //         result(0, 0) = (*this)(1, 1) * dt;
// //         result(1, 0) = -(*this)(1, 0) * dt;
// //         result(0, 1) = -(*this)(0, 1) * dt;
// //         result(1, 1) = (*this)(0, 0) * dt;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr Inverse() const
// //     {
// //         SimMatrixSqr r(*this);
// //         Inverse(r);
// //         return r;
// //     }

// //     SIM_CUDA_CALLABLE tSimVector2<Type>
// //     Solve(const tSimVector<Type, 2> &b) const
// //     {
// //         return Inverse() * b;
// //     }
// //     SIM_CUDA_CALLABLE void Eigen(tSimVector<Type, 2> &eigVals,
// //                                  SimMatrix<Type, 2, 2> &eigVecs) const
// //     {
// //         Type b = -Trace();
// //         Type c = Det();
// //         Type delta = sqrt(b * b - 4 * c);
// //         eigVals[0] = (-b + delta) * Type(0.5);
// //         eigVals[1] = (-b - delta) * Type(0.5);

// //         if (eigVals[0] < eigVals[1])
// //         {
// //             std::swap(eigVals[0], eigVals[1]);
// //         }

// //         tSimVector2<Type> v1(m_data[0] - eigVals[1], m_data[1]);
// //         tSimVector2<Type> v2(m_data[0] - eigVals[0], m_data[1]);
// //         Type len1 = v1.SqrLength(), len2 = v2.SqrLength();
// //         if (len1 == 0 && len2 == 0)
// //         {
// //             eigVecs[0] = eigVecs[3] = 1;
// //             eigVecs[1] = eigVecs[2] = 0;
// //         }
// //         else
// //         {
// //             v1 /= sqrt(len1);
// //             v2 /= sqrt(len2);
// //             eigVecs[0] = v1[0];
// //             eigVecs[1] = v1[1];
// //             eigVecs[2] = v2[0];
// //             eigVecs[3] = v2[1];
// //         }
// //     }
// //     SIM_CUDA_CALLABLE void Eigen(tSimVector<Type, 2> &eigVals) const
// //     {
// //         Type b = -Trace();
// //         Type c = Det();
// //         Type delta = sqrt(b * b - 4 * c);
// //         eigVals[0] = (-b + delta) * Type(0.5);
// //         eigVals[1] = (-b - delta) * Type(0.5);
// //         if (eigVals[0] < eigVals[1])
// //         {
// //             swap(eigVals[0], eigVals[1]);
// //         }
// //     }
// //     SIM_CUDA_CALLABLE tSimVector2<Type> Eigen() const
// //     {
// //         tSimVector2<Type> x;
// //         Eigen(x);
// //         return x;
// //     }
// // };

// // /*!
// //  * \class SimMatrix3
// //  *
// //  * \brief
// //  *
// //  * \author zhendong_wang
// //  * \date 十二月 2019
// //  */

// // template <class Type> class SimMatrixSqr<Type, 3>
// // {

// // protected:
// //     static constexpr int DIM = 3;
// //     static constexpr int nElements = DIM * DIM;

// //     Type m_data[nElements];

// // public:
// //     SIM_CUDA_CALLABLE SimMatrixSqr()
// //     {
// //         Type zero(0);
// //         for (int i = 0; i < 9; ++i)
// //             m_data[i] = zero;
// //     }
// //     template <typename OtherType>
// //     SIM_CUDA_CALLABLE SimMatrixSqr(const OtherType &v)
// //     {
// //         for (int i = 0; i < 9; ++i)
// //             m_data[i] = Type(v);
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr(const Type *data)
// //     {
// //         for (int i = 0; i < 9; ++i)
// //             m_data[i] = data[i];
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr(const SimMatrix<Type, 3, 3> &mat3)
// //     {
// //         for (int i = 0; i < 9; ++i)
// //             m_data[i] = mat3[i];
// //     }

// //     SIM_CUDA_CALLABLE const Type &operator()(int i, int j) const
// //     {
// //         return m_data[j * DIM + i];
// //     }
// //     SIM_CUDA_CALLABLE Type &operator()(int i, int j)
// //     {
// //         return m_data[j * DIM + i];
// //     }
// //     SIM_CUDA_CALLABLE const Type &operator[](int i) const { return m_data[i]; }
// //     SIM_CUDA_CALLABLE Type &operator[](int i) { return m_data[i]; }
// //     SIM_CUDA_CALLABLE tSimVector3<Type>
// //     operator*(const tSimVector3<Type> &rhs) const
// //     {
// //         tSimVector3<Type> ans;
// //         ans[0] = m_data[0] * rhs[0] + m_data[3] * rhs[1] + m_data[6] * rhs[2];
// //         ans[1] = m_data[1] * rhs[0] + m_data[4] * rhs[1] + m_data[7] * rhs[2];
// //         ans[2] = m_data[2] * rhs[0] + m_data[5] * rhs[1] + m_data[8] * rhs[2];
// //         return ans;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr operator*(const Type &rhs) const
// //     {
// //         SimMatrixSqr ans;
// //         for (int i = 0; i < 9; ++i)
// //             ans[i] = m_data[i] * rhs;
// //         return ans;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator*=(const Type &x)
// //     {
// //         for (size_t i = 0; i < nElements; ++i)
// //             (*this)[i] *= x;
// //         return *this;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator=(const SimMatrix<Type, 3, 3> &rhs)
// //     {
// //         for (int i = 0; i < nElements; ++i)
// //             m_data[i] = rhs[i];
// //         return *this;
// //     }

// //     // Operators: +, - with mat
// // #define SimMatrix_ARITHMATIC(OP)                                               \
// //     SIM_CUDA_CALLABLE SimMatrixSqr operator OP(const SimMatrixSqr &rhs) const  \
// //     {                                                                          \
// //         SimMatrixSqr out;                                                      \
// //         for (int i = 0; i < nElements; ++i)                                    \
// //             out[i] = m_data[i] OP rhs[i];                                      \
// //         return out;                                                            \
// //     }

// //     SimMatrix_ARITHMATIC(+) SimMatrix_ARITHMATIC(-)
// // #undef SimMatrix_ARITHMATIC

// // // Operators: +=, -=, = with mat
// // #define SimMatrix_ARITHMATIC2(OP)                                              \
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator OP(const SimMatrixSqr &rhs)       \
// //     {                                                                          \
// //         for (int i = 0; i < nElements; ++i)                                    \
// //             m_data[i] OP rhs[i];                                               \
// //         return *this;                                                          \
// //     }

// //         SimMatrix_ARITHMATIC2(+=) SimMatrix_ARITHMATIC2(-=)
// // #undef SimMatrix_ARITHMATIC2

// //             SIM_CUDA_CALLABLE Type Det() const
// //     {
// //         return m_data[0] * (m_data[4] * m_data[8] - m_data[7] * m_data[5]) -
// //                m_data[3] * (m_data[1] * m_data[8] - m_data[7] * m_data[2]) +
// //                m_data[6] * (m_data[1] * m_data[5] - m_data[4] * m_data[2]);
// //     }
// //     SIM_CUDA_CALLABLE void Inverse(SimMatrixSqr &result) const
// //     {
// //         const SimMatrixSqr &self = *this;

// //         Type dt = 1 / Det();
// //         result(0, 0) = dt * (self(1, 1) * self(2, 2) - self(1, 2) * self(2, 1));
// //         result(1, 0) = dt * (self(1, 2) * self(2, 0) - self(1, 0) * self(2, 2));
// //         result(2, 0) = dt * (self(1, 0) * self(2, 1) - self(1, 1) * self(2, 0));

// //         result(0, 1) = dt * (self(0, 2) * self(2, 1) - self(0, 1) * self(2, 2));
// //         result(1, 1) = dt * (self(0, 0) * self(2, 2) - self(0, 2) * self(2, 0));
// //         result(2, 1) = dt * (self(0, 1) * self(2, 0) - self(0, 0) * self(2, 1));

// //         result(0, 2) = dt * (self(0, 1) * self(1, 2) - self(0, 2) * self(1, 1));
// //         result(1, 2) = dt * (self(0, 2) * self(1, 0) - self(0, 0) * self(1, 2));
// //         result(2, 2) = dt * (self(0, 0) * self(1, 1) - self(0, 1) * self(1, 0));
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr Inverse() const
// //     {
// //         SimMatrixSqr r(*this);
// //         Inverse(r);
// //         return r;
// //     }

// //     SIM_CUDA_CALLABLE tSimVector3<Type>
// //     Solve(const tSimVector<Type, 3> &b) const
// //     {
// //         return Inverse() * b;
// //     }

// //     SIM_CUDA_CALLABLE void Eigen(tSimVector<Type, 3> &eigVals,
// //                                  SimMatrixSqr &eigVecs) const
// //     {
// //         SimMatrixSqr::Eigen();
// //     }
// //     SIM_CUDA_CALLABLE void Eigen(tSimVector<Type, 3> &eigVals) const
// //     {
// //         const SimMatrixSqr &self = (*this);
// //         Type p = sqr(self(0, 1)) + sqr(self(0, 2)) + sqr(self(1, 2));
// //         if (p == Type(0))
// //         {
// //             eigVals[0] = self(0, 0);
// //             eigVals[1] = self(1, 1);
// //             eigVals[2] = self(2, 2);
// //         }
// //         else
// //         {
// //             Type q = self.trace() * (Type(1) / Type(3));
// //             p = sqr(self(0, 0) - q) + sqr(self(1, 1) - q) +
// //                 sqr(self(2, 2) - q) + 2 * p;
// //             p = sqrt(p / Type(6));
// //             SimMatrixSqr B = self;
// //             for (size_t i = 0; i < 3; ++i)
// //                 B(i, i) -= q;
// //             B *= Type(1) / p;
// //             Type r = B.det() / Type(2);
// //             Type phi = acos(r) / Type(3);
// //             if (r <= Type(-1))
// //                 phi = Type(LDP_CONST_PI) / Type(3);
// //             else if (r >= Type(1))
// //                 phi = Type(0);
// //             eigVals[0] = q + Type(2) * p * cos(phi);
// //             eigVals[2] =
// //                 q +
// //                 Type(2) * p * cos(phi + Type(LDP_CONST_PI) * Type(2) / Type(3));
// //             eigVals[1] = Type(3) * q - eigVals[0] - eigVals[2];
// //         }
// //     }
// //     SIM_CUDA_CALLABLE tSimVector3<Type> Eigen() const
// //     {
// //         tSimVector3<Type> x;
// //         Eigen(x);
// //         return x;
// //     }

// //     static SIM_CUDA_CALLABLE SimMatrixSqr Zeros()
// //     {
// //         SimMatrixSqr zero(Type(0));
// //         return zero;
// //     }
// //     static SIM_CUDA_CALLABLE SimMatrixSqr Identity(Type scalar = Type(1))
// //     {
// //         SimMatrixSqr I(Type(0));
// //         for (int i = 0; i < DIM; ++i)
// //         {
// //             I(i, i) = scalar;
// //         }
// //         return I;
// //     }
// // };

// // /*!
// //  * \class SimMatrix4
// //  *
// //  * \brief
// //  *
// //  * \author zhendong_wang
// //  * \date 十二月 2019
// //  */

// // template <class Type> class SIM_MAT4_ALIGN(Type) SimMatrixSqr<Type, 4>
// // {

// // protected:
// //     static constexpr int DIM = 4;
// //     static constexpr int nElements = DIM * DIM;

// //     Type m_data[nElements];

// // public:
// //     SIM_CUDA_CALLABLE SimMatrixSqr()
// //     {
// //         Type zero(0);
// //         for (int i = 0; i < 16; ++i)
// //             m_data[i] = zero;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr(const Type &v)
// //     {
// //         for (int i = 0; i < 16; ++i)
// //             m_data[i] = v;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr(const Type *data)
// //     {
// //         for (int i = 0; i < 16; ++i)
// //             m_data[i] = data[i];
// //     }
// //     /*SIM_CUDA_CALLABLE SimMatrixSqr
// //     (
// //             const tSimVector<Type, 4>& a_col, const tSimVector<Type, 4>& b_col,
// //             const tSimVector<Type, 4>& c_col, const tSimVector<Type, 4>& d_col,
// //     bool colMajor = true
// //     )
// //     {
// //             SimMatrixSqr& self = *this;

// //             if (colMajor)
// //             {
// //                     for (int r = 0; r < 4; ++r)
// //                             self(r, 0) = a_col[r];
// //                     for (int r = 0; r < 4; ++r)
// //                             self(r, 1) = b_col[r];
// //                     for (int r = 0; r < 4; ++r)
// //                             self(r, 2) = c_col[r];
// //                     for (int r = 0; r < 4; ++r)
// //                             self(r, 3) = d_col[r];
// //             }
// //             else
// //             {
// //                     for (int r = 0; r < 4; ++r)
// //                             self(0, r) = a_col[r];
// //                     for (int r = 0; r < 4; ++r)
// //                             self(1, r) = b_col[r];
// //                     for (int r = 0; r < 4; ++r)
// //                             self(2, r) = c_col[r];
// //                     for (int r = 0; r < 4; ++r)
// //                             self(3, r) = d_col[r];
// //             }
// //     }*/

// //     SIM_CUDA_CALLABLE const Type &operator()(int i, int j) const
// //     {
// //         return m_data[j * N + i];
// //     }
// //     SIM_CUDA_CALLABLE Type &operator()(int i, int j)
// //     {
// //         return m_data[j * N + i];
// //     }
// //     SIM_CUDA_CALLABLE const Type &operator[](int i) const { return m_data[i]; }
// //     SIM_CUDA_CALLABLE Type &operator[](int i) { return m_data[i]; }

// //     SIM_CUDA_CALLABLE SimMatrixSqr operator*(const Type &rhs) const
// //     {
// //         return SimMatrixSqr::operator*(rhs);
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator*=(const Type &x)
// //     {
// //         for (size_t i = 0; i < nElements; ++i)
// //             (*this)[i] *= x;
// //         return *this;
// //     }
// //     SIM_CUDA_CALLABLE SimMatrixSqr &operator=(const SimMatrix<Type, 4, 4> &rhs)
// //     {
// //         for (int i = 0; i < 16; ++i)
// //             m_data[i] = rhs[i];
// //     }

// //     SIM_CUDA_CALLABLE SimMatrixSqr<Type, 3> GetRotationPart() const
// //     {
// //         SimMatrixSqr<Type, 3> R;
// //         for (int y = 0; y < 3; ++y)
// //             for (int x = 0; x < 3; ++x)
// //                 R(y, x) = (*this)(y, x);
// //         return R;
// //     }
// //     SIM_CUDA_CALLABLE tSimVector3<Type> GetTranslationPart() const
// //     {
// //         tSimVector3<Type> t;
// //         for (int y = 0; y < 3; ++y)
// //             t[y] = (*this)(y, 3);
// //         return t;
// //     }
// //     SIM_CUDA_CALLABLE void SetRotationPart(const SimMatrixSqr<Type, 3> &R)
// //     {
// //         for (int y = 0; y < 3; ++y)
// //             for (int x = 0; x < 3; ++x)
// //                 (*this)(y, x) = R(y, x);
// //     }
// //     SIM_CUDA_CALLABLE void SetTranslationPart(const tSimVector3<Type> &t)
// //     {
// //         for (int y = 0; y < 3; ++y)
// //             (*this)(y, 3) = t[y];
// //     }
// // };

// //////////////////////////////////////////////////////////////////////////

// template <typename Type> using SimMatrix2 = SimMatrix<Type, 2, 2>;
// template <typename Type> using SimMatrix3 = SimMatrix<Type, 3, 3>;
// template <typename Type> using SimMatrix4 = SimMatrix<Type, 4, 4>;

// typedef SimMatrix2<float> SimMatrix2f;
// typedef SimMatrix3<float> SimMatrix3f;
// typedef SimMatrix4<float> SimMatrix4f;

// typedef SimMatrix<float, 9, 9> SimMatrix9f;
// typedef SimMatrix<float, 9, 2> SimMatrix92f;
// typedef SimMatrix<float, 2, 3> SimMatrix23f;
// typedef SimMatrix<float, 3, 2> SimMatrix32f;

// //////////////////////////////////////////////////////////////////////////

// template <typename Type>
// SIM_CUDA_CALLABLE bool JacobiImplement(Type *A, int astep, Type *W, Type *V,
//                                        int vstep, int n, int *buf)
// {
//     int i, j, k, m;

//     if (V)
//     {
//         for (i = 0; i < n; ++i)
//         {
//             for (j = 0; j < n; ++j)
//                 V[i * vstep + j] = Type(0);
//             V[i * vstep + i] = Type(1);
//         }
//     }

//     int iters, maxIters = n * n * 30;

//     int *indR = buf;
//     int *indC = indR + n;
//     Type mv = (Type)0;

//     for (k = 0; k < n; ++k)
//     {
//         W[k] = A[(astep + 1) * k];
//         if (k < n - 1)
//         {
//             for (m = k + 1, mv = std::abs(A[astep * k + m]), i = k + 2; i < n;
//                  ++i)
//             {
//                 Type val = std::abs(A[astep * k + i]);
//                 if (mv < val)
//                     mv = val, m = i;
//             }
//             indR[k] = m;
//         }
//         if (k > 0)
//         {
//             for (m = 0, mv = std::abs(A[k]), i = 1; i < k; ++i)
//             {
//                 Type val = std::abs(A[astep * i + k]);
//                 if (mv < val)
//                     mv = val, m = i;
//             }
//             indC[k] = m;
//         }
//     }

//     if (n > 1)
//         for (iters = 0; iters < maxIters; ++iters)
//         {
//             // find index (k,l) of pivot p
//             for (k = 0, mv = std::abs(A[indR[0]]), i = 1; i < n - 1; ++i)
//             {
//                 Type val = std::abs(A[astep * i + indR[i]]);
//                 if (mv < val)
//                     mv = val, k = i;
//             }
//             int l = indR[k];
//             for (i = 1; i < n; ++i)
//             {
//                 Type val = std::abs(A[astep * indC[i] + i]);
//                 if (mv < val)
//                     mv = val, k = indC[i], l = i;
//             }

//             Type p = A[astep * k + l];
//             if (std::abs(p) <= std::numeric_limits<Type>::epsilon())
//                 break;
//             Type y = (Type)((W[l] - W[k]) * 0.5);
//             Type t = std::abs(y) + hypot(p, y);
//             Type s = hypot(p, t);
//             Type c = t / s;
//             s = p / s;
//             t = (p / t) * p;
//             if (y < 0)
//                 s = -s, t = -t;
//             A[astep * k + l] = 0;

//             W[k] -= t;
//             W[l] += t;

//             Type a0, b0;

// #undef ldp_eig_rotate
// #define ldp_eig_rotate(v0, v1)                                                 \
//     a0 = v0, b0 = v1, v0 = a0 * c - b0 * s, v1 = a0 * s + b0 * c

//             // rotate rows and columns k and l
//             for (i = 0; i < k; ++i)
//                 ldp_eig_rotate(A[astep * i + k], A[astep * i + l]);
//             for (i = k + 1; i < l; ++i)
//                 ldp_eig_rotate(A[astep * k + i], A[astep * i + l]);
//             for (i = l + 1; i < n; ++i)
//                 ldp_eig_rotate(A[astep * k + i], A[astep * l + i]);

//             // rotate eigenvectors
//             if (V)
//                 for (i = 0; i < n; ++i)
//                     ldp_eig_rotate(V[vstep * k + i], V[vstep * l + i]);

// #undef ldp_eig_rotate

//             for (j = 0; j < 2; ++j)
//             {
//                 int idx = j == 0 ? k : l;
//                 if (idx < n - 1)
//                 {
//                     for (m = idx + 1, mv = std::abs(A[astep * idx + m]),
//                         i = idx + 2;
//                          i < n; ++i)
//                     {
//                         Type val = std::abs(A[astep * idx + i]);
//                         if (mv < val)
//                             mv = val, m = i;
//                     }
//                     indR[idx] = m;
//                 }
//                 if (idx > 0)
//                 {
//                     for (m = 0, mv = std::abs(A[idx]), i = 1; i < idx; ++i)
//                     {
//                         Type val = std::abs(A[astep * i + idx]);
//                         if (mv < val)
//                             mv = val, m = i;
//                     }
//                     indC[idx] = m;
//                 }
//             }
//         }

//     // sort eigenvalues & eigenvectors
//     for (k = 0; k < n - 1; ++k)
//     {
//         m = k;
//         for (i = k + 1; i < n; ++i)
//         {
//             if (W[m] < W[i])
//                 m = i;
//         }
//         if (k != m)
//         {
//             swap(W[m], W[k]);
//             if (V)
//                 for (i = 0; i < n; ++i)
//                     swap(V[vstep * m + i], V[vstep * k + i]);
//         }
//     }

//     return true;
// }

// template <typename Type, int M, int N>
// SIM_CUDA_CALLABLE SimMatrix<Type, M, N>
// OuterProduct(const tSimVector<Type, M> &vecM, const tSimVector<Type, N> &vecN)
// {
//     SimMatrix<Type, M, N> ans;
//     for (int i = 0; i < M; ++i)
//     {
//         for (int j = 0; j < N; ++j)
//         {
//             ans(i, j) = vecM[i] * vecN[j];
//         }
//     }
//     return ans;
// }

// //////////////////////////////////////////////////////////////////////////

// template <typename Type, int N, int M>
// inline std::ostream &operator<<(std::ostream &out,
//                                 const SimMatrix<Type, N, M> &v)
// {
//     for (size_t i = 0; i < N; ++i)
//     {
//         for (size_t j = 0; j < M; ++j)
//             out << std::left << std::setw(10) << v(i, j) << " ";
//         out << std::endl;
//     }
//     return out;
// }

// template <typename Type, int N, int M>
// inline std::istream &operator>>(std::istream &in,
//                                 const SimMatrix<Type, N, M> &v)
// {
//     for (int i = 0; i < N; ++i)
//         for (int j = 0; j < M; ++j)
//             in >> v(i, j);
//     return in;
// }

// // SIM_SIMULATION_SPACE_END
// // SIM_NAMESPACE_END

// #endif // SDSIMULATION_SimMatrix_H